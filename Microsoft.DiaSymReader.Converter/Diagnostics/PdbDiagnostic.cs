// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the License.txt file in the project root for more information.

using System;
using System.Globalization;
using Microsoft.CodeAnalysis.Collections;
using Roslyn.Utilities;

namespace Microsoft.DiaSymReader.Tools
{
    public readonly struct PdbDiagnostic : IEquatable<PdbDiagnostic>
    {
        public PdbDiagnosticId Id { get; }
        public int Token { get; }
        public object[] Args { get; }

        internal PdbDiagnostic(PdbDiagnosticId id, int token, object[] args)
        {
            Id = id;
            Token = token;
            Args = args;
        }

        public override bool Equals(object? obj) => 
            obj is PdbDiagnostic other && Equals(other);

        public bool Equals(PdbDiagnostic other) =>
            Id == other.Id &&
            Token == other.Token &&
            SequenceComparer<object>.Instance.Equals(Args, other.Args);

        public override int GetHashCode() =>
            Hash.Combine((int)Id, Hash.Combine(Token, Hash.CombineValues(Args)));

        public override string ToString() =>
            ToString(CultureInfo.CurrentCulture);

        public string ToString(IFormatProvider formatProvider)
        {
            string location = (Token != 0) ? ": " + string.Format(formatProvider, ConverterResources.DiagnosticLocation, Token) : "";
            return $"PDB{(int)Id:D4}{location}: {GetMessage(formatProvider)}";
        }

        public string? GetMessage(IFormatProvider formatProvider)
        {
            if (formatProvider == null)
            {
                throw new ArgumentNullException(nameof(formatProvider));
            }

            var template = Id.GetMessageTemplate();
            if (template == null)
            {
                return null;
            }

            return (Args?.Length > 0) ? string.Format(formatProvider, template, Args) : template;
        }
    }
}


namespace Microsoft.DiaSymReader.Tools
{
    // <auto-generated>
    internal static partial class ConverterResources
    {
        private static global::System.Resources.ResourceManager s_resourceManager;
        internal static global::System.Resources.ResourceManager ResourceManager => s_resourceManager ?? (s_resourceManager = new global::System.Resources.ResourceManager(typeof(ConverterResources)));
        internal static global::System.Globalization.CultureInfo Culture { get; set; }
#if !NET20
        [global::System.Runtime.CompilerServices.MethodImpl(global::System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
#endif
        internal static string GetResourceString(string resourceKey, string defaultValue = null) => ResourceManager.GetString(resourceKey, Culture);
        /// <summary>Invalid PDB format: {0}</summary>
        internal static string @InvalidPdbFormat => GetResourceString("InvalidPdbFormat");
        /// <summary>Invalid user entry point in the source PDB</summary>
        internal static string @InvalidUserEntryPointInSourcePdb => GetResourceString("InvalidUserEntryPointInSourcePdb");
        /// <summary>Metadata not available</summary>
        internal static string @MetadataNotAvailable => GetResourceString("MetadataNotAvailable");
        /// <summary>Specified PE was built with Portable PDB</summary>
        internal static string @SpecifiedPEBuiltWithPortablePdb => GetResourceString("SpecifiedPEBuiltWithPortablePdb");
        /// <summary>Specified PE file doesn't have any PDB associated with it</summary>
        internal static string @SpecifiedPEFileHasNoAssociatedPdb => GetResourceString("SpecifiedPEFileHasNoAssociatedPdb");
        /// <summary>Stream must be readable</summary>
        internal static string @StreamMustBeReadable => GetResourceString("StreamMustBeReadable");
        /// <summary>Stream must be seakable</summary>
        internal static string @StreamMustBeSeakable => GetResourceString("StreamMustBeSeakable");
        /// <summary>Stream must be writable</summary>
        internal static string @StreamMustBeWritable => GetResourceString("StreamMustBeWritable");
        /// <summary>Method associated with local scope has no body</summary>
        internal static string @MethodAssociatedWithLocalScopeHasNoBody => GetResourceString("MethodAssociatedWithLocalScopeHasNoBody");
        /// <summary>Method containing local variables has no local signature</summary>
        internal static string @MethodContainingLocalVariablesHasNoLocalSignature => GetResourceString("MethodContainingLocalVariablesHasNoLocalSignature");
        /// <summary>Local constant name too long</summary>
        internal static string @LocalConstantNameTooLong => GetResourceString("LocalConstantNameTooLong");
        /// <summary>Local constant name too long</summary>
        internal static string @LocalVariableNameTooLong => GetResourceString("LocalVariableNameTooLong");
        /// <summary>Import string is too long. Ignoring the import: '{0}'</summary>
        internal static string @ImportStringTooLong => GetResourceString("ImportStringTooLong");
        /// <summary>Local scope ranges nesting is invalid</summary>
        internal static string @LocalScopeRangesNestingIsInvalid => GetResourceString("LocalScopeRangesNestingIsInvalid");
        /// <summary>The type of import is not supported (type token {0:X8})</summary>
        internal static string @UnsupportedImportType => GetResourceString("UnsupportedImportType");
        /// <summary>An extern alias was not defined for assembly reference {0:X8}</summary>
        internal static string @UndefinedAssemblyReferenceAlias => GetResourceString("UndefinedAssemblyReferenceAlias");
        /// <summary>Unknown import definition kind: {0}</summary>
        internal static string @UnknownImportDefinitionKind => GetResourceString("UnknownImportDefinitionKind");
        /// <summary>token 0x{0:X8}</summary>
        internal static string @DiagnosticLocation => GetResourceString("DiagnosticLocation");
        /// <summary>ForwardMethodInfo custom debug information forwards to non-existent method: 0x{0:X8}</summary>
        internal static string @ForwardedToUndefinedMethod => GetResourceString("ForwardedToUndefinedMethod");
        /// <summary>ForwardMethodInfo custom debug information forwards to a method with no scope: 0x{0:X8}</summary>
        internal static string @ForwardedToMethodWithNoScope => GetResourceString("ForwardedToMethodWithNoScope");
        /// <summary>Both ForwardMethodInfo custom debug information and imports are specified</summary>
        internal static string @BothForwardMethodInfoAndImportsSpecified => GetResourceString("BothForwardMethodInfoAndImportsSpecified");
        /// <summary>Invalid type name specified in StateMachineTypeName custom debug information: {0}</summary>
        internal static string @InvalidStateMachineTypeName => GetResourceString("InvalidStateMachineTypeName");
        /// <summary>Both StateMachineTypeName custom debug information and imports are specified</summary>
        internal static string @BothStateMachineTypeNameAndImportsSpecified => GetResourceString("BothStateMachineTypeNameAndImportsSpecified");
        /// <summary>Multiple DynamicLocals custom debug information records specified for the same local variable slot: {0}</summary>
        internal static string @DuplicateDynamicLocals => GetResourceString("DuplicateDynamicLocals");
        /// <summary>Multiple TupleElementNames custom debug information records specified for the same local variable slot: {0}</summary>
        internal static string @DuplicateTupleElementNamesForSlot => GetResourceString("DuplicateTupleElementNamesForSlot");
        /// <summary>Multiple TupleElementNames custom debug information records specified for the same local constant: '{0}' [{1}, {2})</summary>
        internal static string @DuplicateTupleElementNamesForConstant => GetResourceString("DuplicateTupleElementNamesForConstant");
        /// <summary>The format of import string is invalid: '{0}'</summary>
        internal static string @InvalidImportStringFormat => GetResourceString("InvalidImportStringFormat");
        /// <summary>The format of import string is invalid: '{0}'</summary>
        internal static string @InvalidEntryPointToken => GetResourceString("InvalidEntryPointToken");
        /// <summary>Invalid scope IL offset range: [{0}, {1})</summary>
        internal static string @InvalidScopeILOffsetRange => GetResourceString("InvalidScopeILOffsetRange");
        /// <summary>Invalid local variable data</summary>
        internal static string @InvalidLocalVariableData => GetResourceString("InvalidLocalVariableData");
        /// <summary>Invalid local constant data</summary>
        internal static string @InvalidLocalConstantData => GetResourceString("InvalidLocalConstantData");
        /// <summary>Invalid local constant signature: '{0}'</summary>
        internal static string @InvalidLocalConstantSignature => GetResourceString("InvalidLocalConstantSignature");
        /// <summary>Invalid local scope</summary>
        internal static string @InvalidLocalScope => GetResourceString("InvalidLocalScope");
        /// <summary>Invalid sequence point document name: '{0}'</summary>
        internal static string @InvalidSequencePointDocument => GetResourceString("InvalidSequencePointDocument");
        /// <summary>Document name doesn't match any pattern in Source Link: '{0}'</summary>
        internal static string @UnmappedDocumentName => GetResourceString("UnmappedDocumentName");
        /// <summary>The scheme of URL specified in Source Link is not http/https: '{0}'</summary>
        internal static string @UrlSchemeIsNotHttp => GetResourceString("UrlSchemeIsNotHttp");
        /// <summary>No supported well-formed URLs found in Source Link</summary>
        internal static string @NoSupportedUrlsFoundInSourceLink => GetResourceString("NoSupportedUrlsFoundInSourceLink");
        /// <summary>The PDB doesn't match debug directory record in the PE file</summary>
        internal static string @PdbNotMatchingDebugDirectory => GetResourceString("PdbNotMatchingDebugDirectory");
        /// <summary>Invalid Source Link data</summary>
        internal static string @InvalidSourceLinkData => GetResourceString("InvalidSourceLinkData");
        /// <summary>Invalid Source Link: {0}</summary>
        internal static string @InvalidSourceLink => GetResourceString("InvalidSourceLink");
        /// <summary>Malformed Source Link URL: '{0}'</summary>
        internal static string @MalformedSourceLinkUrl => GetResourceString("MalformedSourceLinkUrl");
        /// <summary>Invalid srcsrv data</summary>
        internal static string @InvalidSourceServerData => GetResourceString("InvalidSourceServerData");
        /// <summary>Invalid embedded source associated with document '{0}'</summary>
        internal static string @InvalidEmbeddedSource => GetResourceString("InvalidEmbeddedSource");
        /// <summary>Inconsistent state machine method mapping -- MoveNext method is associated with two distinct kickoff methods: 0x{0:X8} and 0x{1:X8}</summary>
        internal static string @InconsistentStateMachineMethodMapping => GetResourceString("InconsistentStateMachineMethodMapping");
        /// <summary>The JSON format is invalid</summary>
        internal static string @InvalidJsonDataFormat => GetResourceString("InvalidJsonDataFormat");
        /// <summary>Invalid srcsvr variable name: '{0}'</summary>
        internal static string @InvalidSrcSvrVariableName => GetResourceString("InvalidSrcSvrVariableName");
        /// <summary>Variable '{0}' can't be set explicitly</summary>
        internal static string @ReservedSrcSvrVariableName => GetResourceString("ReservedSrcSvrVariableName");
        /// <summary>Value of srcsvr variable '{0}' contains invalid characters</summary>
        internal static string @InvalidSrcSvrVariableValue => GetResourceString("InvalidSrcSvrVariableValue");
        /// <summary>Source file checksum size doesn't match the hash algorithm '{0}': '{1}'</summary>
        internal static string @SourceChecksumAlgorithmSizeMismatch => GetResourceString("SourceChecksumAlgorithmSizeMismatch");
        /// <summary>none</summary>
        internal static string @None => GetResourceString("None");

    }
}
